import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,e as n,b as t,a as s,d as l,r,o as d}from"./app-BqdhXfNE.js";const p={};function k(o,i){const a=r("Mermaid");return d(),h("div",null,[i[0]||(i[0]=n(`<h2 id="一、引言" tabindex="-1"><a class="header-anchor" href="#一、引言"><span>一、引言</span></a></h2><p>在Java并发编程中，<code>synchronized</code>关键字是最基本的同步机制之一。从JDK 1.6开始，为了提升锁的性能，Java虚拟机对<code>synchronized</code>进行了重大优化，引入了<strong>锁升级机制</strong>，将锁分为偏向锁、轻量级锁和重量级锁三个级别。这种优化使得<code>synchronized</code>在不同并发场景下能够自动选择最适合的锁实现，从而在保证线程安全的同时，最大化地提升程序性能。</p><p>本文将深入解析<code>synchronized</code>的锁升级机制，包括各类型锁的实现原理、升级过程以及在实际应用中的性能特点。</p><h2 id="二、synchronized的基本原理" tabindex="-1"><a class="header-anchor" href="#二、synchronized的基本原理"><span>二、synchronized的基本原理</span></a></h2><p>在了解锁升级机制之前，我们需要先回顾一下<code>synchronized</code>的基本原理。</p><h3 id="_2-1-synchronized的使用方式" tabindex="-1"><a class="header-anchor" href="#_2-1-synchronized的使用方式"><span>2.1 synchronized的使用方式</span></a></h3><p><code>synchronized</code>可以用于以下三种场景：</p><ol><li><strong>修饰实例方法</strong>：锁是当前实例对象</li><li><strong>修饰静态方法</strong>：锁是当前类的Class对象</li><li><strong>修饰代码块</strong>：锁是括号里指定的对象</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1. 修饰实例方法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> instanceMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 同步代码</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 2. 修饰静态方法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> staticMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 同步代码</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 3. 修饰代码块</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> blockMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 同步代码</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-对象头与mark-word" tabindex="-1"><a class="header-anchor" href="#_2-2-对象头与mark-word"><span>2.2 对象头与Mark Word</span></a></h3><p>要理解<code>synchronized</code>的锁升级机制，首先需要了解Java对象的内存布局。在HotSpot虚拟机中，Java对象的内存布局分为三部分：</p><ol><li><strong>对象头（Header）</strong>：存储对象的元数据信息，如哈希码、GC分代年龄、锁状态等</li><li><strong>实例数据（Instance Data）</strong>：存储对象的实际成员变量值</li><li><strong>对齐填充（Padding）</strong>：用于保证对象大小是8字节的整数倍</li></ol><p>其中，对象头是实现<code>synchronized</code>的关键，它包含两部分信息：</p><ul><li><strong>Mark Word</strong>：存储对象的哈希码、GC分代年龄、锁状态标志等</li><li><strong>类型指针</strong>：指向对象所属类的元数据指针</li></ul><p>Mark Word的结构会根据对象的锁状态发生变化，不同的锁状态对应不同的Mark Word结构：</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit</th><th>2bit</th><th>1bit</th><th>描述</th></tr></thead><tbody><tr><td>无锁</td><td>对象哈希码</td><td>对象分代年龄</td><td>0</td><td>01</td><td>0</td><td>无锁状态</td></tr><tr><td>偏向锁</td><td>线程ID（23bit）</td><td>epoch（2bit）</td><td>1</td><td>01</td><td>0</td><td>偏向锁状态</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>对象分代年龄</td><td>0</td><td>00</td><td>0</td><td>轻量级锁状态</td></tr><tr><td>重量级锁</td><td>指向重量级锁（Monitor）的指针</td><td>对象分代年龄</td><td>0</td><td>10</td><td>0</td><td>重量级锁状态</td></tr><tr><td>GC标记</td><td>空</td><td>对象分代年龄</td><td>0</td><td>11</td><td>0</td><td>GC标记状态</td></tr></tbody></table><h2 id="三、偏向锁-biased-locking" tabindex="-1"><a class="header-anchor" href="#三、偏向锁-biased-locking"><span>三、偏向锁（Biased Locking）</span></a></h2><h3 id="_3-1-偏向锁的设计初衷" tabindex="-1"><a class="header-anchor" href="#_3-1-偏向锁的设计初衷"><span>3.1 偏向锁的设计初衷</span></a></h3><p>偏向锁是JDK 1.6引入的一种锁优化机制，其设计初衷是为了<strong>减少无竞争场景下的锁开销</strong>。在大多数应用中，锁不仅不存在竞争，而且总是由同一个线程多次获取。在这种情况下，使用传统的轻量级锁或重量级锁会带来不必要的性能开销。</p><h3 id="_3-2-偏向锁的实现原理" tabindex="-1"><a class="header-anchor" href="#_3-2-偏向锁的实现原理"><span>3.2 偏向锁的实现原理</span></a></h3><p>偏向锁的核心思想是：当一个线程第一次获取锁时，虚拟机将对象头中的Mark Word设置为偏向模式，并记录获取锁的线程ID。之后该线程再次获取锁时，无需进行CAS操作，只需检查Mark Word中的线程ID是否与当前线程ID一致即可。</p><h3 id="_3-3-偏向锁的获取过程" tabindex="-1"><a class="header-anchor" href="#_3-3-偏向锁的获取过程"><span>3.3 偏向锁的获取过程</span></a></h3>`,22)),t(a,{code:"eJxLy8kvT85ILCpRCHHhUgACx+jnu/Y/X9H9dMPcF+unvujb/rR/2sspjbEKurp2Ck7VzxY3PJu/1DexKFshPL8oxSapyO7ZjPVPJyx7smPXs+kLgCqfd2171tBYCzbMCaSrBqigRsE5+sne/c+nrHB2DH6xbt/zveuAGkC6nzb2P50w8dmKhU/39MeCNTmDrXKpBqp8Nrn3yd45CEuedUx42jUfYrYLwmzXaJA7902HmAV0A1hH5/IXC3ueTuh5tnbpk92Lny9ohBgP0Qc0rEbBLfrZnM7nq+c92dUJ1jFpycspDXBDIMrdwK5xj37a2/5813Kgo1/s3f2yvR/IhiuB+BJsogc0gCBh6OmCcPrTnp0vW3shTvdAcjqSAMRNXAAdqsag"}),i[1]||(i[1]=s("ol",null,[s("li",null,"线程尝试获取锁时，检查对象头的Mark Word是否处于无锁状态（01）"),s("li",null,"如果是无锁状态，使用CAS操作将Mark Word设置为偏向模式，记录当前线程ID"),s("li",null,"如果CAS成功，线程获得偏向锁，执行同步代码"),s("li",null,"如果CAS失败，说明有竞争，偏向锁会被撤销并升级为轻量级锁")],-1)),i[2]||(i[2]=s("h3",{id:"_3-4-偏向锁的撤销过程",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_3-4-偏向锁的撤销过程"},[s("span",null,"3.4 偏向锁的撤销过程")])],-1)),i[3]||(i[3]=s("p",null,[l("当有其他线程尝试获取同一把锁时，偏向锁会被撤销，撤销过程需要"),s("strong",null,"停顿持有锁的线程"),l("，并将锁升级为轻量级锁或重量级锁。")],-1)),t(a,{code:"eJxdj99KAkEUxu97inkB3yCEdNUeoLvBiwqiiyCQoAsncKJYttzWoEzE/mxZBqFbIVqzWC+z58zsWzQ7YxTO1WHO7/sdvq2d3f3N7fXaHllzloh+KxSOJ0ncluJbPp/C67WKLtXZFIJ2esGrJJfLkwLF7iHwHjY59jzgAbTO9VJ2j2yoakQFwxbr+NDA20fLZpRBljdqeexE0HqCYQfH8YGJFLMIg+k7DuNEhIw4VI2+5GwE0ad6C6E/Tj4EXt1lmpMJNri9NI8ZESOluhXrc/LlJhGedZcMpMP2k5EyBd+VYqCVahanbqDnrOJ/+lfBSOWPTl1/gXZM1VWK/B76vm2I3kCFTbsv272ZK/P5B+qQxCw="}),i[4]||(i[4]=n('<p>撤销过程如下：</p><ol><li>暂停持有偏向锁的线程</li><li>检查持有锁的线程是否仍然存活</li><li>如果线程已经死亡，将对象头设置为无锁状态</li><li>如果线程仍然存活，将锁升级为轻量级锁或重量级锁</li><li>恢复线程执行</li></ol><h3 id="_3-5-偏向锁的适用场景" tabindex="-1"><a class="header-anchor" href="#_3-5-偏向锁的适用场景"><span>3.5 偏向锁的适用场景</span></a></h3><p>偏向锁适用于<strong>只有一个线程多次获取锁</strong>的场景，例如单线程环境下的同步操作。在这种情况下，偏向锁可以大幅减少锁开销，提升程序性能。</p><h2 id="四、轻量级锁-lightweight-locking" tabindex="-1"><a class="header-anchor" href="#四、轻量级锁-lightweight-locking"><span>四、轻量级锁（Lightweight Locking）</span></a></h2><h3 id="_4-1-轻量级锁的设计初衷" tabindex="-1"><a class="header-anchor" href="#_4-1-轻量级锁的设计初衷"><span>4.1 轻量级锁的设计初衷</span></a></h3><p>轻量级锁是JDK 1.6引入的另一种锁优化机制，其设计初衷是为了<strong>减少多线程竞争但竞争不激烈场景下的锁开销</strong>。在这种场景下，线程之间的竞争是间歇性的，使用重量级锁会带来较大的性能开销。</p><h3 id="_4-2-轻量级锁的实现原理" tabindex="-1"><a class="header-anchor" href="#_4-2-轻量级锁的实现原理"><span>4.2 轻量级锁的实现原理</span></a></h3><p>轻量级锁的核心思想是：通过<strong>CAS操作</strong>来尝试获取锁，而无需进入操作系统的内核态。</p><h3 id="_4-3-轻量级锁的获取过程" tabindex="-1"><a class="header-anchor" href="#_4-3-轻量级锁的获取过程"><span>4.3 轻量级锁的获取过程</span></a></h3>',10)),t(a,{code:"eJxlkM1Kw0AUhfd9inmBvoEU+mcr6EYFF0MXNSpChUAQXDQuukrUxEZsrdCKrVYThJoIojEh5mVyJ5O3cDKBUOwsL9935tx7dCKeCcdt6RTt1gqIvTKOvTC2rsB5oPaQXn9D/y4Z9FqoWCyhCoaJRaYquGbkLkAdg++t7UslBtB3B4Lhpih00PahIEoHLR5X4V4Vw1wH9QvsH/oxg/nnVlvqoD1GpTaoTh6QWVVu1XAUhPHAqpZ3yDgk+lOupxbRFDBu/ok1Lta7qXKrR8GEk/c2GK9ENeDy8Zxj9RST2VxG6zjd8XdEAz9R+rFnskQuXZh0poGhkcVL5D/H0172Q6ayPBk1MFXeyGjlVJxr8CbNboasVmguVVga8OANDLrCqkSulyh6XqtV+AOcDdlz"}),i[5]||(i[5]=n('<ol><li>线程尝试获取锁时，虚拟机在当前线程的栈帧中创建一个**锁记录（Lock Record）**对象</li><li>将锁记录的<code>obj</code>字段指向锁对象，并将对象头中的Mark Word复制到锁记录中</li><li>使用CAS操作将对象头中的Mark Word替换为指向锁记录的指针</li><li>如果CAS成功，线程获得轻量级锁，执行同步代码</li><li>如果CAS失败，说明有竞争，虚拟机将自旋尝试获取锁，如果自旋失败，锁会升级为重量级锁</li></ol><h3 id="_4-4-轻量级锁的释放过程" tabindex="-1"><a class="header-anchor" href="#_4-4-轻量级锁的释放过程"><span>4.4 轻量级锁的释放过程</span></a></h3><ol><li>线程释放锁时，使用CAS操作将锁记录中的Mark Word（即对象头的原始值）恢复到对象头中</li><li>如果CAS成功，轻量级锁释放成功</li><li>如果CAS失败，说明有其他线程尝试获取锁，需要唤醒等待线程并将锁升级为重量级锁</li></ol><h3 id="_4-5-自旋锁-spin-lock" tabindex="-1"><a class="header-anchor" href="#_4-5-自旋锁-spin-lock"><span>4.5 自旋锁（Spin Lock）</span></a></h3><p>轻量级锁在竞争时会使用<strong>自旋锁</strong>来尝试获取锁。自旋锁的核心思想是：当线程尝试获取锁失败时，不立即挂起线程，而是循环尝试获取锁，直到成功或达到自旋次数上限。</p><p>自旋锁的优点是避免了线程上下文切换的开销，缺点是会消耗CPU资源。因此，自旋锁适用于<strong>锁持有时间短、竞争不激烈</strong>的场景。</p><p>JDK 1.6引入了<strong>自适应自旋锁</strong>，虚拟机可以根据前一次自旋获取锁的情况，动态调整自旋次数。</p><h3 id="_4-6-轻量级锁的适用场景" tabindex="-1"><a class="header-anchor" href="#_4-6-轻量级锁的适用场景"><span>4.6 轻量级锁的适用场景</span></a></h3><p>轻量级锁适用于<strong>多线程竞争但竞争不激烈</strong>的场景，例如两个线程交替获取同一把锁的场景。在这种情况下，轻量级锁可以避免重量级锁的上下文切换开销，提升程序性能。</p><h2 id="五、重量级锁-heavyweight-locking" tabindex="-1"><a class="header-anchor" href="#五、重量级锁-heavyweight-locking"><span>五、重量级锁（Heavyweight Locking）</span></a></h2><h3 id="_5-1-重量级锁的实现原理" tabindex="-1"><a class="header-anchor" href="#_5-1-重量级锁的实现原理"><span>5.1 重量级锁的实现原理</span></a></h3><p>重量级锁是最传统的锁实现方式，它依赖于**操作系统的互斥量（Mutex）**来实现线程同步。当多个线程竞争同一把锁时，未获取到锁的线程会被阻塞并挂起，等待获取到锁的线程释放锁后被唤醒。</p><h3 id="_5-2-重量级锁的获取与释放过程" tabindex="-1"><a class="header-anchor" href="#_5-2-重量级锁的获取与释放过程"><span>5.2 重量级锁的获取与释放过程</span></a></h3><ol><li>线程尝试获取锁时，检查对象头的Mark Word是否处于无锁状态</li><li>如果是无锁状态，使用CAS操作将Mark Word设置为指向重量级锁（Monitor）的指针</li><li>如果CAS成功，线程获得重量级锁，执行同步代码</li><li>如果CAS失败，说明有其他线程持有锁，当前线程会被阻塞并加入等待队列</li><li>线程释放锁时，唤醒等待队列中的线程，让它们重新尝试获取锁</li></ol><h3 id="_5-3-monitor对象" tabindex="-1"><a class="header-anchor" href="#_5-3-monitor对象"><span>5.3 Monitor对象</span></a></h3><p>在Java虚拟机中，每个对象都关联一个<strong>Monitor对象</strong>（也称为管程或监视器）。Monitor对象是重量级锁的核心，它包含以下几个关键部分：</p>',16)),t(a,{code:"eJxtkc1OwkAUhfc+RV+ABXVrWOmSECMJi4YFKAiJaU2tIURMIIJQBDVSwIDyYyRiiIIuUEuEl2E607dwftpCE7u4bTr3u+ecO/EjKbWfiMgKF9ze4PBzcho9lCPHCc4viUlFksH4B3304axmdPK0IZASY7JA61ZU9oHfGlCrRiVnPKimloOtPNQXcHgV5jweH7cjKnJaoJXbiykEgG8qmBfQ9Re4aawD5n0XlJrhlQYdEIokFYEUG0eTC6gNU/jPv2RMPKBvdxbWB0edpa6iRRF/0/OgV2AnXuo2AyaPaFx3rGU4/5m1BWK0PDWyuXMK+mk7fNXN5mcGjwnYcwg7b+JuYtUo3S6/dZqFmWMYehqBag+HIOSuTYJyDxQGBHO2tZ4LazDYiU/okE2bxbKhzS1dtGjjUfbS3LyhvqB+BbxXjHEd5+MFF2lmW7A7cAxYrnm2HO3ZvLzDqrwlytPbZDu1V2aLhRhSmC5nDdYtSkoynsaSm07idgeUJq7Eqzv8A25vPXw="}),i[6]||(i[6]=n('<ul><li><strong>Entry Set</strong>：等待获取锁的线程队列</li><li><strong>Owner</strong>：当前持有锁的线程</li><li><strong>Wait Set</strong>：调用<code>wait()</code>方法等待的线程队列</li></ul><p>Monitor对象的实现依赖于操作系统的互斥量机制，因此重量级锁的获取和释放都需要进行<strong>用户态与内核态的切换</strong>，这是重量级锁性能较低的主要原因。</p><h3 id="_5-4-重量级锁的适用场景" tabindex="-1"><a class="header-anchor" href="#_5-4-重量级锁的适用场景"><span>5.4 重量级锁的适用场景</span></a></h3><p>重量级锁适用于<strong>多线程激烈竞争</strong>的场景，例如多个线程同时访问共享资源的场景。在这种情况下，虽然重量级锁的开销较大，但它可以确保线程安全和公平性。</p><h2 id="六、锁升级的完整过程" tabindex="-1"><a class="header-anchor" href="#六、锁升级的完整过程"><span>六、锁升级的完整过程</span></a></h2><p>现在，我们来总结一下<code>synchronized</code>锁升级的完整过程：</p>',6)),t(a,{code:"eJxLy8kvT85ILCpRCHHhUgACx+inHXOfLu9+3rXtWUPj+z2znk1f8HJKY6yCrq5dzfM1a57saHiyY9XzXfufr+h+0bf9af80oGyNglP008b+pxMmAjkKhgaGsWCznMCanrZue7J7GkTH0w1zX6yfCtFXo+CM0PRs0pKXUxog2pxB2hRcol/s3f2yvf/5ruUgQw0MIJIuYDOdHYOfLtn4YsvSZx3TXrSveja9+8W21mfTt9UouEa/bO9FaDOEagMTxaVJ6UWJBRkKT9fvfLFx4dMlW3wTi7IVwvOLUiDehYRAPEg02sDQSgHqd4hnIMJAz1kpwJ0NdRNUh4GVArKbIZKuMH1WCsgug0im5qUgOa+kMidVwVEhLTMnx0o5zTJNp7ikKD871UrZ2NgYSYUTVEVSEi4VzjAzkpJwqHCBmZGGS4UrzIw0SxQVAIqC6Z0="}),i[7]||(i[7]=n(`<ol><li><strong>初始状态</strong>：对象处于无锁状态（Mark Word为01）</li><li><strong>偏向锁</strong>：当第一个线程获取锁时，锁升级为偏向锁，Mark Word记录线程ID（101）</li><li><strong>轻量级锁</strong>：当有其他线程尝试获取同一把锁时，偏向锁被撤销，锁升级为轻量级锁，Mark Word指向线程栈中的锁记录（00）</li><li><strong>重量级锁</strong>：当轻量级锁的CAS操作失败或自旋达到上限时，锁升级为重量级锁，Mark Word指向Monitor对象（10）</li></ol><p>锁升级的过程是<strong>不可逆</strong>的，即一旦锁升级为轻量级锁或重量级锁，就不会再降级回偏向锁或无锁状态。</p><h2 id="七、锁升级的性能特点" tabindex="-1"><a class="header-anchor" href="#七、锁升级的性能特点"><span>七、锁升级的性能特点</span></a></h2><p>不同类型的锁具有不同的性能特点：</p><table><thead><tr><th>锁类型</th><th>适用场景</th><th>性能特点</th><th>开销</th></tr></thead><tbody><tr><td>偏向锁</td><td>单线程多次获取锁</td><td>几乎无开销</td><td>极低</td></tr><tr><td>轻量级锁</td><td>多线程交替获取锁</td><td>自旋开销</td><td>较低</td></tr><tr><td>重量级锁</td><td>多线程激烈竞争</td><td>上下文切换开销</td><td>较高</td></tr></tbody></table><h2 id="八、锁升级的源码分析" tabindex="-1"><a class="header-anchor" href="#八、锁升级的源码分析"><span>八、锁升级的源码分析</span></a></h2><p>为了更深入地理解锁升级机制，我们来看一下OpenJDK中的相关源码实现。</p><h3 id="_8-1-偏向锁的源码分析" tabindex="-1"><a class="header-anchor" href="#_8-1-偏向锁的源码分析"><span>8.1 偏向锁的源码分析</span></a></h3><p>偏向锁的获取过程主要在<code>markOop.cpp</code>文件的<code>try_set_mark()</code>方法中实现：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> markOopDesc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">try_set_mark</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">markOop</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> new_mark</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // CAS操作设置Mark Word</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ( Atomic::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmpxchg_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(new_mark, </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                              (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void**</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                              (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mark</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> mark</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() );</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-2-轻量级锁的源码分析" tabindex="-1"><a class="header-anchor" href="#_8-2-轻量级锁的源码分析"><span>8.2 轻量级锁的源码分析</span></a></h3><p>轻量级锁的获取过程主要在<code>objectMonitor.cpp</code>文件的<code>TryLock()</code>方法中实现：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> ObjectMonitor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">TryLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  Thread </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Self </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Thread::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">current</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">own </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> _owner;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (own </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 对象未被锁定，尝试获取锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Atomic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmpxchg_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(Self, </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">_owner, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 获取锁成功</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (own </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Self) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 重入锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    _recursions</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 获取锁失败</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-3-重量级锁的源码分析" tabindex="-1"><a class="header-anchor" href="#_8-3-重量级锁的源码分析"><span>8.3 重量级锁的源码分析</span></a></h3><p>重量级锁的获取过程主要在<code>objectMonitor.cpp</code>文件的<code>enter()</code>方法中实现：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> ObjectMonitor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">enter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TRAPS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  Thread </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Self </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> THREAD;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 尝试快速获取锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">TryLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 获取锁失败，进入慢速路径</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  EnterI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(THREAD);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>EnterI()</code>方法会将线程加入等待队列并挂起线程：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> ObjectMonitor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">EnterI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TRAPS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  Thread </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Self </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> THREAD;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 将线程加入等待队列</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  Self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">_ParkEvent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">reset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  AddWaiter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(Self);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 挂起线程</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  Self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">_ParkEvent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">park</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 线程被唤醒后，重新尝试获取锁</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="九、锁升级的实际应用与优化建议" tabindex="-1"><a class="header-anchor" href="#九、锁升级的实际应用与优化建议"><span>九、锁升级的实际应用与优化建议</span></a></h2><h3 id="_9-1-锁升级的实际应用" tabindex="-1"><a class="header-anchor" href="#_9-1-锁升级的实际应用"><span>9.1 锁升级的实际应用</span></a></h3><p>在实际应用中，我们应该根据具体的并发场景选择合适的锁策略：</p><ol><li><strong>单线程场景</strong>：使用偏向锁可以获得最佳性能</li><li><strong>低并发场景</strong>：使用轻量级锁可以避免上下文切换开销</li><li><strong>高并发场景</strong>：使用重量级锁可以确保线程安全和公平性</li></ol><h3 id="_9-2-优化建议" tabindex="-1"><a class="header-anchor" href="#_9-2-优化建议"><span>9.2 优化建议</span></a></h3><ol><li><strong>减少锁持有时间</strong>：尽量缩短同步代码块的长度，减少线程持有锁的时间</li><li><strong>减小锁粒度</strong>：将一个大锁拆分为多个小锁，减少锁竞争</li><li><strong>使用无锁数据结构</strong>：在合适的场景下，使用<code>Atomic</code>类等无锁数据结构代替<code>synchronized</code></li><li><strong>避免锁嵌套</strong>：尽量避免锁的嵌套使用，减少死锁风险和锁竞争</li><li><strong>合理使用volatile</strong>：在不需要原子性操作的场景下，使用<code>volatile</code>关键字代替<code>synchronized</code></li></ol><h2 id="十、总结" tabindex="-1"><a class="header-anchor" href="#十、总结"><span>十、总结</span></a></h2><p><code>synchronized</code>的锁升级机制是JDK 1.6引入的一项重要优化，它通过将锁分为偏向锁、轻量级锁和重量级锁三个级别，在不同的并发场景下自动选择最适合的锁实现，从而在保证线程安全的同时，最大化地提升程序性能。</p><ul><li><strong>偏向锁</strong>：适用于单线程多次获取锁的场景，几乎无锁开销</li><li><strong>轻量级锁</strong>：适用于多线程交替获取锁的场景，避免上下文切换开销</li><li><strong>重量级锁</strong>：适用于多线程激烈竞争的场景，确保线程安全和公平性</li></ul><p>理解<code>synchronized</code>的锁升级机制对于编写高效的并发程序至关重要。在实际应用中，我们应该根据具体的并发场景选择合适的锁策略，并遵循相关的优化建议，以提升程序的并发性能。</p>`,28))])}const A=e(p,[["render",k]]),y=JSON.parse('{"path":"/posts/thread/24-synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E6%9C%BA%E5%88%B6.html","title":"Java并发编程之synchronized锁升级机制深入解析","lang":"en-US","frontmatter":{"title":"Java并发编程之synchronized锁升级机制深入解析","tag":["Java","并发编程","synchronized","锁升级","偏向锁","轻量级锁","重量级锁"],"category":"并发编程","description":"深入解析Java中synchronized关键字的锁升级机制，包括偏向锁、轻量级锁、重量级锁的实现原理、升级过程和性能特点","date":"2025-12-08T00:00:00.000Z","author":"nikola","isOriginal":true,"sticky":false,"timeline":true,"article":true,"star":false,"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java并发编程之synchronized锁升级机制深入解析\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-08T07:29:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"nikola\\"}]}"],["meta",{"property":"og:url","content":"https://nikolazhang.github.io/posts/thread/24-synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:title","content":"Java并发编程之synchronized锁升级机制深入解析"}],["meta",{"property":"og:description","content":"深入解析Java中synchronized关键字的锁升级机制，包括偏向锁、轻量级锁、重量级锁的实现原理、升级过程和性能特点"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-08T07:29:52.000Z"}],["meta",{"property":"article:author","content":"nikola"}],["meta",{"property":"article:tag","content":"重量级锁"}],["meta",{"property":"article:tag","content":"轻量级锁"}],["meta",{"property":"article:tag","content":"偏向锁"}],["meta",{"property":"article:tag","content":"锁升级"}],["meta",{"property":"article:tag","content":"synchronized"}],["meta",{"property":"article:tag","content":"并发编程"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2025-12-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-08T07:29:52.000Z"}]]},"git":{"createdTime":1765129672000,"updatedTime":1765178992000,"contributors":[{"name":"我小叮当","username":"","email":"nikolazhang@163.com","commits":2}]},"readingTime":{"minutes":13.56,"words":4068},"filePathRelative":"posts/thread/24-synchronized锁升级机制.md"}');export{A as comp,y as data};
