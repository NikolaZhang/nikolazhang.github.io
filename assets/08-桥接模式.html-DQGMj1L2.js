import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as t,o as n}from"./app-DgU4tkOd.js";const e="/assets/image-4-ufX7y8Z0.png",l={};function h(p,i){return n(),a("div",null,[...i[0]||(i[0]=[t('<blockquote><p>桥接模式通过抽象和实现部分的分离，使得两者可以独立变化。抽象部分定义抽象类，维护一个对实现对象的引用。 实现部分定义实现接口，提供不同的实现。这样就可以通过组合不同的抽象类和实现类来创建对象，提高了系统的灵活性。</p></blockquote><figure><img src="'+e+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>主要角色：</p><ul><li>抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。</li><li>扩展抽象（RefinedAbstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。</li><li>抽象实现（Implementor）：定义实现接口，提供基本操作的接口。</li><li>具体实现（ConcreteImplementor）：实现实现接口的具体类。</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><p>在设计模式中类与类之间的关系主要有6种：依赖、关联、聚合、组合、继承、实现，它们之间的耦合度依次增加。子类必须实现抽象父类中的所有方法，父类抽象方法的变更，必然导致子类的变更。这是一种强关联关系。强关联有必然使我们的系统不易扩展。所以桥梁模式为化解强关联提供了一种解决方案。</p><p>桥接模式，抽象和实现的分离，可以理解为功能性的抽象和内部实现的分离。</p><p>当组件比较复杂，比如：属性存在复杂的依赖关系时，可以通过桥接模式进行拆分成多个组件。使得每个组件可以单独扩展，以此来简化组件，实现解耦。</p></div><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><h3 id="抽象" tabindex="-1"><a class="header-anchor" href="#抽象"><span>抽象</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Implementor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> operationImpl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="扩展抽象" tabindex="-1"><a class="header-anchor" href="#扩展抽象"><span>扩展抽象</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ConcreteImplementorA</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Implementor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> operationImpl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;ConcreteImplementorA operation&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="抽象实现" tabindex="-1"><a class="header-anchor" href="#抽象实现"><span>抽象实现</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> abstract</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Abstraction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    protected</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Implementor</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> impl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> setImplementor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Implementor</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> impl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">impl</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> impl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    abstract</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> operation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里聚合了<code>Implementor</code>，通过该类来实现我们的具体功能。</p><h3 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现"><span>具体实现</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RefinedAbstraction</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Abstraction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> operation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // do something</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        impl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">operationImpl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在抽象功能的实现类中，调用内部实现方法，完成<code>operation</code>的操作。</p><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Client</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Abstraction</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> abstraction</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> RefinedAbstraction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        abstraction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setImplementor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ConcreteImplementorA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        abstraction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">operation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Abstraction</code>和<code>Implementor</code>是<code>Bridge模式</code>中定义的两个抽象/接口,用于解耦抽象部分和实现部分。</p><p>为了保证原有组件的功能，在<code>Abstraction</code>中聚合<code>Implementor</code>，除了实现<code>Abstraction</code>自身的功能，通过调用<code>Implementor</code>的方法来完成其他功能。</p><p>这样<code>Abstraction</code>和<code>Implementor</code>可以独立变化，提高了系统的灵活性。</p><h2 id="与其他设计模式的对比" tabindex="-1"><a class="header-anchor" href="#与其他设计模式的对比"><span>与其他设计模式的对比</span></a></h2><h3 id="桥接模式-vs-适配器模式" tabindex="-1"><a class="header-anchor" href="#桥接模式-vs-适配器模式"><span>桥接模式 vs 适配器模式</span></a></h3><table><thead><tr><th>特性</th><th>桥接模式</th><th>适配器模式</th></tr></thead><tbody><tr><td>目的</td><td>分离抽象与实现，使两者独立变化</td><td>兼容接口不匹配的类</td></tr><tr><td>实现时间</td><td>设计阶段考虑使用</td><td>已有类接口不匹配时使用</td></tr><tr><td>接口关系</td><td>抽象与实现是平行的，无继承关系</td><td>适配器与适配者有继承或组合关系</td></tr><tr><td>扩展性</td><td>高（抽象和实现可独立扩展）</td><td>中（主要解决接口不兼容问题）</td></tr><tr><td>适用场景</td><td>系统需要跨越多个维度变化</td><td>已有系统需要集成新接口</td></tr></tbody></table><h3 id="桥接模式-vs-装饰器模式" tabindex="-1"><a class="header-anchor" href="#桥接模式-vs-装饰器模式"><span>桥接模式 vs 装饰器模式</span></a></h3><table><thead><tr><th>特性</th><th>桥接模式</th><th>装饰器模式</th></tr></thead><tbody><tr><td>目的</td><td>分离抽象与实现，使两者独立变化</td><td>动态扩展对象功能</td></tr><tr><td>结构</td><td>抽象类持有实现接口的引用</td><td>装饰器包装原对象，保持接口一致</td></tr><tr><td>继承关系</td><td>避免了多层继承</td><td>基于组合优于继承的原则</td></tr><tr><td>扩展性</td><td>高（两个维度独立扩展）</td><td>高（可动态添加多个装饰器）</td></tr><tr><td>适用场景</td><td>系统需要跨越多个维度变化</td><td>需要动态扩展对象功能而不修改原类</td></tr></tbody></table><h3 id="桥接模式-vs-策略模式" tabindex="-1"><a class="header-anchor" href="#桥接模式-vs-策略模式"><span>桥接模式 vs 策略模式</span></a></h3><table><thead><tr><th>特性</th><th>桥接模式</th><th>策略模式</th></tr></thead><tbody><tr><td>目的</td><td>分离抽象与实现，使两者独立变化</td><td>定义算法家族，使算法可互相替换</td></tr><tr><td>关注点</td><td>抽象与实现的分离</td><td>算法的封装与替换</td></tr><tr><td>结构</td><td>抽象类持有实现接口的引用</td><td>上下文持有策略接口的引用</td></tr><tr><td>扩展性</td><td>高（两个维度独立扩展）</td><td>高（可扩展新的算法）</td></tr><tr><td>适用场景</td><td>系统需要跨越多个维度变化</td><td>需要在运行时选择不同算法</td></tr></tbody></table><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>桥接模式是一种结构型设计模式，它通过将抽象部分与实现部分分离，使它们可以独立地变化。这种模式的核心思想是使用组合关系代替继承关系，从而避免了继承带来的强耦合问题。</p><h3 id="核心思想" tabindex="-1"><a class="header-anchor" href="#核心思想"><span>核心思想</span></a></h3><p>将抽象部分与实现部分分离，使它们可以独立地变化，通过组合关系代替继承关系，实现抽象与实现的解耦。</p><h3 id="主要角色" tabindex="-1"><a class="header-anchor" href="#主要角色"><span>主要角色</span></a></h3><ul><li><strong>抽象（Abstraction）</strong>：定义抽象接口，通常包含对实现接口的引用，维护抽象部分的功能。</li><li><strong>扩展抽象（RefinedAbstraction）</strong>：对抽象的扩展，可以是抽象类的子类或具体实现类，实现抽象部分的具体功能。</li><li><strong>实现接口（Implementor）</strong>：定义实现接口，提供基本操作的接口，隐藏具体实现细节。</li><li><strong>具体实现（ConcreteImplementor）</strong>：实现实现接口的具体类，提供具体的实现逻辑。</li></ul><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li><strong>分离抽象与实现</strong>：使抽象部分和实现部分可以独立地扩展和变化。</li><li><strong>减少继承层次</strong>：通过组合关系代替继承关系，避免了多层继承带来的复杂性。</li><li><strong>提高系统灵活性</strong>：可以动态地组合不同的抽象类和实现类，以满足不同的需求。</li><li><strong>符合开闭原则</strong>：扩展抽象部分或实现部分时，不需要修改原有代码。</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><ul><li><strong>增加系统复杂度</strong>：引入了更多的类和接口，增加了系统的理解和设计难度。</li><li><strong>需要正确识别抽象与实现</strong>：需要准确地识别系统中的抽象部分和实现部分，否则可能导致设计不当。</li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h3><ul><li><strong>系统需要跨越多个维度变化</strong>：当系统需要在多个维度上进行扩展时，桥接模式可以有效地减少类的数量。</li><li><strong>避免多层继承导致的类爆炸</strong>：当使用继承会导致大量子类时，桥接模式是一个更好的选择。</li><li><strong>希望抽象与实现独立变化</strong>：当抽象部分和实现部分需要独立地扩展和变化时，桥接模式可以提供很好的支持。</li></ul><h3 id="实际应用" tabindex="-1"><a class="header-anchor" href="#实际应用"><span>实际应用</span></a></h3><p>在实际开发中，桥接模式常用于：</p><ul><li>GUI开发中，窗口抽象与底层实现的分离</li><li>数据库驱动程序中，数据库访问抽象与具体数据库实现的分离</li><li>操作系统中，文件系统抽象与具体存储设备实现的分离</li><li>网络通信中，协议抽象与具体传输方式实现的分离</li></ul>`,43)])])}const k=s(l,[["render",h]]),o=JSON.parse('{"path":"/posts/pattern/08-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html","title":"桥接模式","lang":"en-US","frontmatter":{"title":"桥接模式","tag":["桥接模式"],"category":"设计模式","description":"动态地给对象添加额外的责任（功能），在运行时增强对象的行为。","banner":"http://image.nikolazhang.top/wallhaven-nrwq11.jpg","date":"2024-01-17T00:00:00.000Z","author":"nikola","icon":"article","isOriginal":true,"sticky":false,"timeline":true,"article":true,"star":false,"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"桥接模式\\",\\"image\\":[\\"http://image.nikolazhang.top/wallhaven-nrwq11.jpg\\"],\\"datePublished\\":\\"2024-01-17T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-05T17:00:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"nikola\\"}]}"],["meta",{"property":"og:url","content":"https://nikolazhang.github.io/posts/pattern/08-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:title","content":"桥接模式"}],["meta",{"property":"og:description","content":"动态地给对象添加额外的责任（功能），在运行时增强对象的行为。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://image.nikolazhang.top/wallhaven-nrwq11.jpg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-05T17:00:42.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"http://image.nikolazhang.top/wallhaven-nrwq11.jpg"}],["meta",{"name":"twitter:image:alt","content":"桥接模式"}],["meta",{"property":"article:author","content":"nikola"}],["meta",{"property":"article:tag","content":"桥接模式"}],["meta",{"property":"article:published_time","content":"2024-01-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-05T17:00:42.000Z"}]]},"git":{"createdTime":1764954042000,"updatedTime":1764954042000,"contributors":[{"name":"我小叮当","username":"","email":"nikolazhang@163.com","commits":1}]},"readingTime":{"minutes":6.08,"words":1823},"filePathRelative":"posts/pattern/08-桥接模式.md"}');export{k as comp,o as data};
