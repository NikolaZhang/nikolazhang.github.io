import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a,f as p,e as r,b as o,d as t,w as i,r as u,o as c}from"./app-ynXKrCuk.js";const d="/images/article/181202/eurekaserver.png",h="/images/article/181202/serverconfig.png",m="/images/article/181202/eurekainstance.png",k={};function g(E,e){const n=u("font");return c(),s("div",null,[e[7]||(e[7]=a("blockquote",null,[a("p",null,"每天更新，用于记录未付学习过程中遇到的知识点、问题，及解决方案。")],-1)),e[8]||(e[8]=a("h1",{id:"_1-服务治理",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_1-服务治理"},[a("span",null,"1 服务治理")])],-1)),e[9]||(e[9]=a("p",null,[t("之前程序的框架结构： "),a("img",{src:d,alt:"结构",loading:"lazy"})],-1)),p("more"),e[10]||(e[10]=r('<h2 id="_1-1-eureka服务治理基础框架的三个核心要素" tabindex="-1"><a class="header-anchor" href="#_1-1-eureka服务治理基础框架的三个核心要素"><span>1.1 Eureka服务治理基础框架的三个核心要素</span></a></h2><ul><li>服务注册中心</li></ul><blockquote><p>Eureka提供的服务端，用于提供服务与发现。</p></blockquote><ul><li>服务提供者</li></ul><blockquote><p>提供服务的应用，可以是一切遵循Eureka通讯机制的应用（不限于springboot）。它将自己提供的服务注册到Eureka。</p></blockquote><ul><li>服务消费者</li></ul><blockquote><p>从服务注册中心获取服务列表，从而使消费者可以知道去何处调用需要的服务。可以通过ribbon和feign实现服务消费。</p></blockquote><h2 id="_1-2-服务治理机制" tabindex="-1"><a class="header-anchor" href="#_1-2-服务治理机制"><span>1.2 服务治理机制</span></a></h2><blockquote><ul><li>服务注册中心1,2相互注册形成高可用集群。</li></ul></blockquote><ul><li>服务提供者注册服务到注册中心。</li><li>服务消费者同样指向注册中心。</li></ul><h3 id="_1-2-1服务提供者" tabindex="-1"><a class="header-anchor" href="#_1-2-1服务提供者"><span>1.2.1服务提供者</span></a></h3>',11)),a("ul",null,[a("li",null,[e[1]||(e[1]=t("服务注册 服务提供者在启动时会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上自身服务的元数据信息。 Eureka Server接收到这个REST请求后，将元数据信息存储在一个双层结构Map中。",-1)),o(n,{color:"red"},{default:i(()=>[...e[0]||(e[0]=[t("第一层key是服务名，第二层key是具体服务的实例名。",-1)])]),_:1}),e[2]||(e[2]=a("code",null,"eureka.client.register-with-eureka=true",-1)),e[3]||(e[3]=t(" 启动注册操作。",-1))]),e[4]||(e[4]=a("li",null,"服务同步 服务提供者虽然会在不同的注册中心注册，但是当服务注册中心会转发请求到与其相连的其他注册中心，从而实现注册中心间的服务同步。通过服务同步，服务提供者的服务信息就可以通多服务注册中心的任一台获取到。",-1)),e[5]||(e[5]=a("li",null,[t("服务续约 服务注册完成后，服务提供者会维护一个心跳，防止EurekaServer“剔除任务”。 "),a("code",null,"eureka.instance.lease-renewal-interval-in-seconds=30"),t(" 设置服务续约任务的调用间隔。 "),a("code",null,"eureka.instance.lease-expiration-duration-in-seconds=90"),t(" 定义服务失效时间。")],-1))]),e[11]||(e[11]=r('<h3 id="_1-2-2-服务消费者" tabindex="-1"><a class="header-anchor" href="#_1-2-2-服务消费者"><span>1.2.2 服务消费者</span></a></h3><ul><li><p>获取服务 当我们启动服务消费者的时候，它会发送一个REST请求给服务注册中心，来获取注册的服务清单。EurekaServer会维护一份只读的服务清单返回给客户端，同时该缓存清单会每隔30秒更新一次。 客户端设置 <code>eureka.client.fetch-register=true</code>（虽然这是默认的） <code>eureka.client.fetch-register-interval-seconds=30</code>设置缓存清单更新时间。</p></li><li><p>服务调用 消费者获取服务清单后，通过服务名可以获取：服务实例名和该实例的元数据信息。 在Ribbon中通过轮询的方式进行调用实例，从而实现客户端的负载均衡。 进行服务调用时优先访问同处一个zone中的服务提供方。若访问不到则访问其他的zone。【每一个客户端对应一个region和一个zone】</p></li><li><p>服务下线 当服务实例进行正常关闭时，会触发一个服务下线的REST请求给EurekaServer，服务注册中心收到请求后，将该服务状态设置为下线<code>down</code>（上线为up）。并把下线事件传播出去。</p></li></ul><h3 id="_1-2-3-服务注册中心" tabindex="-1"><a class="header-anchor" href="#_1-2-3-服务注册中心"><span>1.2.3 服务注册中心</span></a></h3><ul><li>失效剔除 当服务实例非正常下线，服务注册中心未收到下线请求。EurekaServer的定时任务会将清单中超时没有续约的服务剔除。</li><li>自我保护</li></ul>',4)),o(n,{color:"red"},{default:i(()=>[...e[6]||(e[6]=[t("EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.",-1)])]),_:1}),e[12]||(e[12]=r('<p>本地调试时基本会在界面看到这条信息。这就是触发了EurekaServer的自我保护机制。EurekaServer在运行期间，会统计心跳失败比例在15分钟内是否低于85%。eureka会将当前实例信息保护起来，不让其过期。 使用<code>eureka.server.enable-self-preservation=false</code>来关闭保护机制。</p><h2 id="_1-3-配置" tabindex="-1"><a class="header-anchor" href="#_1-3-配置"><span>1.3 配置</span></a></h2><p>以上所有的应用都可以视为Eureka服务治理体系中的客户端。故，eureka客户端的配置包含两部分：</p><blockquote><ul><li>服务注册相关配置：服务注册中心地址、服务获取间隔时间、可用区域等</li><li>服务实例相关的配置信息：服务实例名称、IP地址、端口号、健康检查路径等。</li></ul></blockquote><h3 id="_1-3-1-服务注册类配置" tabindex="-1"><a class="header-anchor" href="#_1-3-1-服务注册类配置"><span>1.3.1 服务注册类配置</span></a></h3><p>可以查看<code>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean</code>所有的配置信息都以eureka.client为前缀。</p><ul><li><p>指定注册中心 <code>eureka.client.serviceUrl.defaultZone=http....</code> 配置多个注册中心使用逗号分隔。 <code>http://&lt;username&gt;:&lt;password&gt;@ip:port/...</code>使用安全校验信息。 <code>eureka.client.enable=true</code> 启用Eureka客户端 <img src="'+h+'" alt="其他配置" loading="lazy"></p></li><li><p><strong>服务实例类配置</strong> 可以查看<code>org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean</code>所有的配置信息都以eureka.instance为前缀。</p><ul><li>元数据</li></ul><blockquote><p>元数据：Eureka客户端在向注册中心发送注册请求时，用来描述自身服务信息的对象。</p></blockquote><p>标准化元数据<code>eureka.instance.&lt;properties&gt;=&lt;value&gt;</code> 自定义元数据<code>eureka.instance.metedataMap.&lt;key&gt;=&lt;value&gt;</code></p><ul><li><p>实例名配置 同一主机启动多实例时的默认配置规则： <code>${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}</code> 对于实例的命名规则可以使用eureka.instance.instanceId参数进行配置。 设置随机端口：<code>server.port=0</code>或者 <code>server.port=${random.int[10000,19999]}</code> 虽然端口名不同但是实例名还是相同的，需要使用下面的方法设置不同的实例名： <code>eureka.instance.instanceId=${spring.application.name}:${random.int}</code></p></li><li><p>端点配置 当我们为应用设置了context-path时，<code>management.context-path=/hello</code>，监控端点都应该加上这个前缀。需要变更actuator模块的访问的路径。 <code>eureka.instance.statusPageUrlPath=${management.context-path}/info</code><code>eureka.instance.healthCheckUrlPath=${management.context-path}/health</code> 使用绝对路径方式： <code>eureka.instance.healthCheckUrl=https://${eureka.instance.hostname}/health</code><code>eureka.instance.statusPageUrl=https://${eureka.instance.hostname}/info</code><code>eureka.instance.homePageUrl=https://${eureka.instance.hostname}/</code></p></li><li><p>健康监测 当服务不能正常提供时，比如服务所依赖的外部资源出现问题时，此时心跳还是在运行，客户端依旧可以使用非正常服务。这是不合理的。 因此需要更加健全的健康状态维护。方法如下： <em>首先在pom xml中引入actuator模块依赖</em><em>配置参数<code>eureka.client.healthcheck.enable=true</code></em></p></li><li><p>其他配置 <img src="'+m+'" alt="其他配置" loading="lazy"></p></li></ul></li></ul><h2 id="_1-4-跨平台支持" tabindex="-1"><a class="header-anchor" href="#_1-4-跨平台支持"><span>1.4 跨平台支持</span></a></h2><p>Eureka的通信机制使用HTTP的REST接口实现，这也是Eureka同其他服务注册工具的一个关键不同点。HTTP是平台无关的，虽然Eureka Server通过java实现，但是其下微服务应用不限于使用java开发。</p><h3 id="_1-4-1-通信协议" tabindex="-1"><a class="header-anchor" href="#_1-4-1-通信协议"><span>1.4.1 通信协议</span></a></h3><blockquote><p>Eureka使用Jersey和XStream配合JSON作为servlet和client之间的通讯协议。也可以选择实现自己的协议来代替。</p></blockquote><hr><p>华丽丽的分隔符！</p>',13))])}const v=l(k,[["render",g]]),S=JSON.parse('{"path":"/posts/springcloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","title":"微服务学习笔记","lang":"en-US","frontmatter":{"isOriginal":true,"title":"微服务学习笔记","date":"2018-12-02T00:00:00.000Z","tag":["eureka"],"category":"技术","description":"主要是eureka的介绍","sticky":false,"timeline":true,"article":true,"star":false,"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"微服务学习笔记\\",\\"image\\":[\\"https://nikolazhang.github.io/images/article/181202/eurekaserver.png\\",\\"https://nikolazhang.github.io/images/article/181202/serverconfig.png\\",\\"https://nikolazhang.github.io/images/article/181202/eurekainstance.png\\"],\\"datePublished\\":\\"2018-12-02T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-31T08:40:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"我小叮当、\\",\\"url\\":\\"https://nikolazhang.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://nikolazhang.github.io/posts/springcloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"}],["meta",{"property":"og:title","content":"微服务学习笔记"}],["meta",{"property":"og:description","content":"主要是eureka的介绍"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://nikolazhang.github.io/images/article/181202/eurekaserver.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-12-31T08:40:08.000Z"}],["meta",{"property":"article:tag","content":"eureka"}],["meta",{"property":"article:published_time","content":"2018-12-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-31T08:40:08.000Z"}]]},"git":{"createdTime":1665625617000,"updatedTime":1735634408000,"contributors":[{"name":"zhangxu","username":"zhangxu","email":"nikolazhang@163.com","commits":5,"url":"https://github.com/zhangxu"},{"name":"nikola","username":"nikola","email":"nikolazhang@163.com","commits":1,"url":"https://github.com/nikola"},{"name":"我小叮当","username":"","email":"nikolazhang@163.com","commits":1}]},"readingTime":{"minutes":5.61,"words":1682},"filePathRelative":"posts/springcloud/微服务学习笔记.md"}');export{v as comp,S as data};
