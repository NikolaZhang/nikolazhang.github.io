---
isOriginal: true
title: 微服务学习笔记（Eureka篇 - 已过时）
date: 2018-12-02
update: 2024-01-01


tag:
  - eureka
  - nacos
category: 技术
description: Eureka服务治理框架介绍（已过时，推荐使用Nacos）
sticky: false
timeline: true
article: true
star: false
---

## 1 Eureka服务治理框架

> ⚠️ **重要提示：Eureka已进入维护模式**
> 当前Spring Cloud官方推荐使用Nacos作为服务注册与发现中心，替代Netflix Eureka。
> 本文内容仅作为Eureka技术参考，实际项目建议使用Nacos。

### 1.1 Eureka服务治理基础框架的三个核心要素

+ 服务注册中心

> Eureka提供的服务端，用于提供服务与发现。

+ 服务提供者

> 提供服务的应用，可以是一切遵循Eureka通讯机制的应用（不限于springboot）。它将自己提供的服务注册到Eureka。

+ 服务消费者

> 从服务注册中心获取服务列表，从而使消费者可以知道去何处调用需要的服务。可以通过ribbon和feign实现服务消费。

### 1.2 服务治理机制
>
>+ 服务注册中心1,2相互注册形成高可用集群。
>
+ 服务提供者注册服务到注册中心。
+ 服务消费者同样指向注册中心。

#### 1.2.1服务提供者

+ 服务注册
服务提供者在启动时会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上自身服务的元数据信息。
Eureka Server接收到这个REST请求后，将元数据信息存储在一个双层结构Map中。第一层key是服务名，第二层key是具体服务的实例名。
`eureka.client.register-with-eureka=true` 启动注册操作。
+ 服务同步
服务提供者虽然会在不同的注册中心注册，但是当服务注册中心会转发请求到与其相连的其他注册中心，从而实现注册中心间的服务同步。通过服务同步，服务提供者的服务信息就可以通多服务注册中心的任一台获取到。
+ 服务续约
服务注册完成后，服务提供者会维护一个心跳，防止EurekaServer“剔除任务”。
`eureka.instance.lease-renewal-interval-in-seconds=30` 设置服务续约任务的调用间隔。
`eureka.instance.lease-expiration-duration-in-seconds=90` 定义服务失效时间。

#### 1.2.2 服务消费者

+ 获取服务
当我们启动服务消费者的时候，它会发送一个REST请求给服务注册中心，来获取注册的服务清单。EurekaServer会维护一份只读的服务清单返回给客户端，同时该缓存清单会每隔30秒更新一次。
客户端设置 `eureka.client.fetch-register=true`（虽然这是默认的）
`eureka.client.fetch-register-interval-seconds=30`设置缓存清单更新时间。

+ 服务调用
消费者获取服务清单后，通过服务名可以获取：服务实例名和该实例的元数据信息。
在Ribbon中通过轮询的方式进行调用实例，从而实现客户端的负载均衡。
进行服务调用时优先访问同处一个zone中的服务提供方。若访问不到则访问其他的zone。【每一个客户端对应一个region和一个zone】

+ 服务下线
当服务实例进行正常关闭时，会触发一个服务下线的REST请求给EurekaServer，服务注册中心收到请求后，将该服务状态设置为下线`down`（上线为up）。并把下线事件传播出去。

#### 1.2.3 服务注册中心

+ 失效剔除
当服务实例非正常下线，服务注册中心未收到下线请求。EurekaServer的定时任务会将清单中超时没有续约的服务剔除。
+ 自我保护
EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
本地调试时基本会在界面看到这条信息。这就是触发了EurekaServer的自我保护机制。EurekaServer在运行期间，会统计心跳失败比例在15分钟内是否低于85%。eureka会将当前实例信息保护起来，不让其过期。
使用`eureka.server.enable-self-preservation=false`来关闭保护机制。

### 1.3 配置

以上所有的应用都可以视为Eureka服务治理体系中的客户端。故，eureka客户端的配置包含两部分：

> + 服务注册相关配置：服务注册中心地址、服务获取间隔时间、可用区域等
> + 服务实例相关的配置信息：服务实例名称、IP地址、端口号、健康检查路径等。

#### 1.3.1 服务注册类配置

可以查看`org.springframework.cloud.netflix.eureka.EurekaClientConfigBean`所有的配置信息都以eureka.client为前缀。

+ 指定注册中心
`eureka.client.serviceUrl.defaultZone=http....`
配置多个注册中心使用逗号分隔。
`http://<username>:<password>@ip:port/...`使用安全校验信息。
`eureka.client.enable=true` 启用Eureka客户端
![其他配置](/images/article/181202/serverconfig.png)

+ **服务实例类配置**
可以查看`org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean`所有的配置信息都以eureka.instance为前缀。
  + 元数据
  > 元数据：Eureka客户端在向注册中心发送注册请求时，用来描述自身服务信息的对象。

    标准化元数据`eureka.instance.<properties>=<value>`
  自定义元数据`eureka.instance.metedataMap.<key>=<value>`

  + 实例名配置
  同一主机启动多实例时的默认配置规则：
  `${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}`
  对于实例的命名规则可以使用eureka.instance.instanceId参数进行配置。
  设置随机端口：`server.port=0`或者 `server.port=${random.int[10000,19999]}`
  虽然端口名不同但是实例名还是相同的，需要使用下面的方法设置不同的实例名：
  `eureka.instance.instanceId=${spring.application.name}:${random.int}`
  + 端点配置
  当我们为应用设置了context-path时，`management.context-path=/hello`，监控端点都应该加上这个前缀。需要变更actuator模块的访问的路径。
  `eureka.instance.statusPageUrlPath=${management.context-path}/info`
  `eureka.instance.healthCheckUrlPath=${management.context-path}/health`
  使用绝对路径方式：
  `eureka.instance.healthCheckUrl=https://${eureka.instance.hostname}/health`
  `eureka.instance.statusPageUrl=https://${eureka.instance.hostname}/info`
  `eureka.instance.homePageUrl=https://${eureka.instance.hostname}/`

  + 健康监测
  当服务不能正常提供时，比如服务所依赖的外部资源出现问题时，此时心跳还是在运行，客户端依旧可以使用非正常服务。这是不合理的。
  因此需要更加健全的健康状态维护。方法如下：
  _首先在pom xml中引入actuator模块依赖_
  _配置参数`eureka.client.healthcheck.enable=true`_

  + 其他配置
  ![其他配置](/images/article/181202/eurekainstance.png)

### 1.4 跨平台支持

Eureka的通信机制使用HTTP的REST接口实现，这也是Eureka同其他服务注册工具的一个关键不同点。HTTP是平台无关的，虽然Eureka Server通过java实现，但是其下微服务应用不限于使用java开发。

#### 1.4.1 通信协议

> Eureka使用Jersey和XStream配合JSON作为servlet和client之间的通讯协议。也可以选择实现自己的协议来代替。

------

## 2 Nacos替代方案介绍

### 2.1 Nacos与Eureka的对比

| 特性 | Eureka | Nacos |
|------|--------|-------|
| 开发维护 | Netflix（已进入维护模式） | 阿里巴巴（活跃维护） |
| 一致性协议 | AP | 同时支持AP和CP |
| 配置中心 | 不支持 | 支持 |
| 动态DNS | 不支持 | 支持 |
| 服务健康检查 | 客户端心跳 | TCP/HTTP/MYSQL/自定义 |
| 性能 | 一般 | 更高 |
| 扩展性 | 一般 | 更好 |
| 管理界面 | 基本 | 丰富 |

### 2.2 从Eureka迁移到Nacos的步骤

#### 2.2.1 服务注册中心迁移

1. **下载并启动Nacos Server**

   ```bash
   # 下载Nacos Server
   # 访问：https://github.com/alibaba/nacos/releases
   
   # 启动Nacos（单机模式）
   sh startup.sh -m standalone
   ```

2. **客户端迁移**

   **Step 1: 替换依赖**

   ```xml
   <!-- 移除Eureka依赖 -->
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   
   <!-- 添加Nacos依赖 -->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

   **Step 2: 更新配置文件**

   ```yaml
   # 移除Eureka配置
   # eureka:
   #   client:
   #     serviceUrl:
   #       defaultZone: http://localhost:8761/eureka/
   
   # 添加Nacos配置
   spring:
     cloud:
       nacos:
         discovery:
           server-addr: localhost:8848
   ```

   **Step 3: 启动类无需修改**
   > `@EnableDiscoveryClient`注解同时支持Eureka和Nacos

### 2.3 Nacos额外功能

+ **配置中心功能**：集中管理配置，支持热更新
+ **服务路由**：支持基于权重的负载均衡和灰度发布
+ **服务降级**：支持流量控制和服务降级
+ **动态DNS**：支持自定义域名解析
+ **多环境支持**：通过namespace实现环境隔离
