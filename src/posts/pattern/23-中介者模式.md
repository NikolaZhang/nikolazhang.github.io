---
title: 中介者模式
tag:
  - 中介者模式
category: 设计模式
description: 定义一个中介对象来封装系列对象间的交互，降低对象间的耦合度。
banner: http://image.nikolazhang.top/wallhaven-nrwq11.jpg
date: 2024-01-27

author: nikola
icon: article

isOriginal: true
sticky: false
timeline: true
article: true
star: false
---


> 中介者模式通过引入一个能够管理对象间消息分布的对象，简化了系统中对象间的通信。该模式可以减少对象间的相互引用，从而提高了对象间的松耦合度，并且它还可以独立地改变其间的交互

![20240128205628](https://raw.githubusercontent.com/NikolaZhang/image-blog/main/23-mediator/20240128205628.png)

中介者模式的主要角色：

1. 抽象中介者（Abstract Mediator）：

这是一个接口或抽象类，定义了同事对象之间交互的公共方法。
它声明了同事对象需要调用的方法来与其它同事对象通信，而不需要知道具体的接收者是谁。
2. 具体中介者（Concrete Mediator）：

实现了抽象中介者的接口，负责协调和管理同事对象间的交互。
具体中介者了解并维护同事对象，并且知道如何根据接收到的消息转发给适当的同事对象，或者执行相应的业务逻辑。
3. 同事类（Colleague）：

同事类是相互协作的对象，它们通过中介者进行通信而不是直接相互引用。
每个同事类都只知道抽象中介者，不知道具体的实现类。
同事类通常会有一个引用指向中介者实例，并通过这个引用调用中介者的方法来与其他同事对象交互。
4. 具体同事类（Concrete Colleague）：

是同事类的具体实现，它们是系统中的各个组件或模块，它们之间的复杂关系通过中介者来进行解耦。

## 代码实现

### 抽象中介者

```java
public abstract class Mediator {


    private Programmer programmer;
    private Designer designer;
    private Manager manager;

    public abstract void sendMessage(String from, String to, String message);


    public Programmer getProgrammer() {
        return programmer;
    }

    public void setProgrammer(Programmer programmer) {
        this.programmer = programmer;
    }

    public Designer getDesigner() {
        return designer;
    }

    public void setDesigner(Designer designer) {
        this.designer = designer;
    }

    public Manager getManager() {
        return manager;
    }

    public void setManager(Manager manager) {
        this.manager = manager;
    }
}
```

### 具体中介者

```java
public class OfficeMediator extends Mediator {

    @Override
    public void sendMessage(String from, String to, String message) {
        if ("programmer".equals(to)) {
            this.getProgrammer().receiveMessage(from, message);
        } else if ("designer".equals(to)) {
            this.getDesigner().receiveMessage(from, message);
        } else if ("manager".equals(to)) {
            this.getManager().receiveMessage(from, message);
        }
    }
}
```

### 同事类

```java
public abstract class Colleague {
    protected Mediator mediator;

    public void setMediator(Mediator mediator) {
        this.mediator = mediator;
    }

    public abstract void receiveMessage(String from, String message);
}
```

### 具体同事类

```java
public class Designer extends Colleague {
    public void sendMessageToManager(String message) {
        mediator.sendMessage("designer", "manager", message);
    }

    public void sendMessageToProgrammer(String message) {
        mediator.sendMessage("designer", "programmer", message);
    }

    @Override
    public void receiveMessage(String from, String message) {
        System.out.println("Designer received message from " + from + ": " + message);
    }
}
```

可以继续创建其他的同事类

```java
public class Manager extends Colleague {
    public void sendMessageToProgrammer(String message) {
        mediator.sendMessage("manager", "programmer", message);
    }

    public void sendMessageToDesigner(String message) {
        mediator.sendMessage("manager", "designer", message);
    }

    @Override
    public void receiveMessage(String from, String message) {
        System.out.println("Manager received message from " + from + ": " + message);
    }
}

public class Programmer extends Colleague {
    public void sendMessageToManager(String message) {
        mediator.sendMessage("programmer", "manager", message);
    }

    public void sendMessageToDesigner(String message) {
        mediator.sendMessage("programmer", "designer", message);
    }

    @Override
    public void receiveMessage(String from, String message) {
        System.out.println("Programmer received message from " + from + ": " + message);
    }
}

```

### 使用

```java
public class Client {
    public static void main(String[] args) {
        // 创建中介者对象
        Mediator mediator = new OfficeMediator();

        // 创建同事对象并设置中介者
        Manager manager = new Manager();
        manager.setMediator(mediator);

        Programmer programmer = new Programmer();
        programmer.setMediator(mediator);

        Designer designer = new Designer();
        designer.setMediator(mediator);

        // 中介者关联各个同事对象
        mediator.setProgrammer(programmer);
        mediator.setDesigner(designer);
        mediator.setManager(manager);

        // 模拟发送消息
        manager.sendMessageToProgrammer("Please review the code.");
        programmer.sendMessageToDesigner("The design needs some adjustment.");
    }
}
```

结果:

![20240211154804](https://raw.githubusercontent.com/NikolaZhang/image-blog/main/23-mediator/20240211154804.png)

## 中介者模式与其他模式的对比

| 模式 | 功能 | 实现方式 | 适用场景 |
| --- | --- | --- | --- |
| **中介者模式** | 减少对象间直接耦合 | 通过中介者统一管理对象间通信 | 对象间存在复杂网状依赖关系时 |
| **观察者模式** | 一对多依赖通知 | 主题维护观察者列表，状态变化时通知所有观察者 | 一个对象状态变化需要影响多个其他对象时 |
| **命令模式** | 封装请求为对象 | 将请求封装为命令，支持队列、撤销等操作 | 需要支持请求的队列化、日志记录或撤销时 |
| **责任链模式** | 避免请求发送者与接收者耦合 | 请求沿责任链传递，直到被处理 | 需要动态决定请求处理者时 |

## 总结

### 核心思想

中介者模式的核心思想是通过引入一个中介对象，将对象间的直接交互转变为通过中介者的间接交互，从而减少对象间的耦合度，使系统结构更加清晰。它遵循了迪米特法则（最少知道原则），每个对象只需要知道中介者，不需要了解其他对象。

### 主要角色

1. **抽象中介者（Abstract Mediator）**：定义同事对象间交互的接口
2. **具体中介者（Concrete Mediator）**：实现中介逻辑，协调同事对象间的通信
3. **同事类（Colleague）**：抽象同事类，持有中介者引用
4. **具体同事类（Concrete Colleague）**：具体业务组件，通过中介者与其他同事通信

### 实现方式

1. 定义抽象中介者接口，包含同事对象间通信的方法
2. 具体中介者实现通信逻辑，管理同事对象引用
3. 同事类持有中介者引用，通过中介者发送和接收消息
4. 客户端创建中介者和同事对象，建立它们之间的关联

### 优缺点

**优点：**

- 减少了对象间的直接耦合，降低了系统复杂度
- 集中管理对象间的交互逻辑，提高了代码的可维护性
- 符合迪米特法则，每个对象只与中介者交互
- 便于扩展新的同事类，只需在中介者中添加相应处理逻辑

**缺点：**

- 中介者可能会变得复杂庞大，成为"上帝对象"
- 中介者与同事类之间可能形成循环依赖
- 如果中介者设计不当，可能导致系统性能下降
- 系统维护需要同时考虑中介者和同事类的逻辑

### 适用场景

- 对象间存在复杂的网状依赖关系
- 希望减少对象间的直接耦合，提高系统的可维护性
- 希望集中管理对象间的交互逻辑
- 需要在多个对象间进行协调和通信
- 系统结构需要清晰，便于理解和扩展

### 实际应用

1. **聊天室系统**：聊天室作为中介者，管理用户间的消息传递
2. **MVC架构**：控制器作为中介者，协调模型和视图间的交互
3. **GUI组件框架**：窗口管理器作为中介者，管理组件间的事件传递
4. **微服务架构**：服务注册中心作为中介者，管理服务间的通信
5. **数据库连接池**：连接池作为中介者，管理数据库连接的分配和回收
