---
title: 模板方法模式
tag:
  - 模板方法模式
category: 设计模式
description: 在一个抽象类中定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。
banner: http://image.nikolazhang.top/wallhaven-nrwq11.jpg
date: 2024-01-29

author: nikola
icon: article

isOriginal: true
sticky: false
timeline: true
article: true
star: false
---

> 模板方法模式，提供了在不重写方法的前提下允许子类重载部分方法的方法。在操作中定义算法的框架，将一些步骤由子类实现。该模式可以在不修改算法结构的情况下，让子类重新定义算法的特定步骤。

![20240211165120](https://raw.githubusercontent.com/NikolaZhang/image-blog/main/14-template-method/20240211165120.png)

## 代码实现

### 抽象类

抽象类定义了算法的骨架，它由一个或多个基本方法和一个模板方法组成。

1. 模板方法是一个具体方法，它实现了算法的框架，并在合适的地方调用基本方法。这个方法通常被声明为`final`，以防止子类重写整个算法流程。
2. 基本方法可以是抽象方法，由子类实现；也可以是具体方法，提供默认实现但允许子类覆盖。

```java
public abstract class AbstractTemplate {

    public final void doAction() {
        clickPowerButton();

        System.out.println("账号：");
        inputUsername();
        System.out.println("密码：");
        inputPassword();

        clickEnterButton();

    }

    public abstract void inputUsername();
    public abstract void inputPassword();


    private void clickPowerButton() {
        System.out.println("按下电源按钮，启动");
    }

    private void clickEnterButton() {
        System.out.println("点击Enter按钮，进入系统");
    }

}

```

### 具体类

```java
public class GuestLogin extends AbstractTemplate {


    @Override
    public void inputUsername() {
        System.out.println("xiaozhang");
    }

    @Override
    public void inputPassword() {
        System.out.println("1234");
    }
}

```

### 使用

```java

public class Client {

    public static void main(String[] args) {
        AbstractTemplate template = new GuestLogin();
        template.doAction();

    }
}

```

结果：

![20240211210731](https://raw.githubusercontent.com/NikolaZhang/image-blog/main/14-template-method/20240211210731.png)

## 与其他设计模式的对比

| 设计模式 | 主要功能 | 实现方式 | 适用场景 |
|---------|---------|---------|--------|
| **模板方法模式** | 算法骨架固定 | 继承 | 算法骨架不变，步骤可变时 |
| **策略模式** | 算法替换 | 组合 | 算法需要频繁切换时 |
| **工厂方法模式** | 对象创建 | 继承 | 需要扩展产品类型时 |
| **建造者模式** | 复杂对象构建 | 组合 | 需要分步构建复杂对象时 |

## 总结

### 核心思想

模板方法模式在一个**抽象类**中定义一个操作的算法骨架，而将一些步骤延迟到子类中实现。这样可以在不修改算法结构的情况下，让子类重新定义算法的特定步骤。

### 主要角色

1. **抽象类(AbstractClass)**：定义算法骨架和基本方法，包括模板方法和抽象方法
2. **具体子类(ConcreteClass)**：实现抽象类中定义的抽象方法，完成特定的业务逻辑

### 实现方式

- 使用**继承**来实现算法步骤的定制
- 模板方法通常被声明为`final`，防止子类重写整个算法流程
- 基本方法可以是抽象方法（必须由子类实现）或具体方法（提供默认实现）

### 优点

1. **复用性**：将算法骨架提取到抽象类中，实现代码复用
2. **扩展性**：子类可以灵活定制算法的特定步骤
3. **封装性**：将不变的算法骨架封装在抽象类中，隐藏实现细节
4. **一致性**：保证了算法骨架的一致性，子类只需要关注特定步骤的实现

### 缺点

1. **灵活性受限**：算法骨架由抽象类固定，难以灵活修改
2. **继承关系紧密**：子类与抽象类之间的耦合度较高
3. **可能导致类数量增加**：每个具体实现都需要一个对应的子类

### 适用场景

1. 当多个类具有相同的算法骨架，但个别步骤有所不同时
2. 当需要控制子类扩展时，模板方法只允许在特定点进行扩展
3. 当需要将复杂算法分解为多个步骤，便于维护和扩展时

### 实际应用

- Java中的InputStream、OutputStream等I/O类中的read()和write()方法
- Spring框架中的各种Template类（如JdbcTemplate、HibernateTemplate）
- 单元测试框架中的测试模板
- 各种框架中的生命周期方法
