---
title: 门面模式
tag:
  - 门面模式
category: 设计模式
description: 为子系统中的一组接口提供一个统一的高层接口，简化了外部调用接口，隐藏内部复杂性。
banner: http://image.nikolazhang.top/wallhaven-nrwq11.jpg
date: 2024-01-20

author: nikola
icon: article

isOriginal: true
sticky: false
timeline: true
article: true
star: false
---

> 门面(Facade)模式是一种结构型设计模式，提供了一个统一的接口，用来访问子系统中的一群接口。门面模式定义了一个高层接口，这个接口使得子系统更容易使用。

![20240120122205](https://raw.githubusercontent.com/NikolaZhang/image-blog/main/11-facade/20240120122205.png)

::: info 使用场景

1. 对复杂子系统提供一个简单接口。
2. 客户端需要和多个子系统进行交互,门面模式提供一个统一接口减少客户端的复杂性。
3. 在层次化结构中,提供系统各层之间的入口点。
:::

## 代码实现

### 子系统的接口

假设我们的子系统中包含多个类，每个类负责不同的功能。

```java
// 子系统1
public class Class1 {
    public void method1() {
        System.out.println("Class1.method1()");
    }
}

// 子系统2
public class Class2 {
    public void method2() {
        System.out.println("Class2.method2()");
    }
}

// 子系统3
public class Class3 {
    public void method3() {
        System.out.println("Class3.method3()");
    }
}

// 子系统4
public class Class4 {
    public void method4() {
        System.out.println("Class4.method4()");
    }
}

// 子系统5
public class Class5 {
    public void method5() {
        System.out.println("Class5.method5()");
    }
}
```

### 门面

门面类将子系统的复杂逻辑封装到简单的接口中，提供给客户端使用。

```java
public class Facade {
    private Class1 class1;
    private Class2 class2;
    private Class3 class3;
    private Class4 class4;
    private Class5 class5;
    
    public Facade() {
        this.class1 = new Class1();
        this.class2 = new Class2();
        this.class3 = new Class3();
        this.class4 = new Class4();
        this.class5 = new Class5();
    }
    
    // 提供简单的接口，封装子系统的复杂逻辑
    public void operation1() {
        System.out.println("Facade.operation1()");
        class1.method1();
        class2.method2();
        class3.method3();
    }
    
    public void operation2() {
        System.out.println("Facade.operation2()");
        class3.method3();
        class4.method4();
        class5.method5();
    }
    
    public void operation3() {
        System.out.println("Facade.operation3()");
        class1.method1();
        class5.method5();
    }
}
```

### 客户端

客户端通过门面类的简单接口与子系统交互，无需了解子系统的内部复杂性。

```java
public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        
        // 客户端只需要调用门面类的简单接口
        facade.operation1();
        System.out.println("\n---");
        facade.operation2();
        System.out.println("\n---");
        facade.operation3();
    }
}
```

## 与其他设计模式的对比

### 门面模式 vs 适配器模式

| 特性 | 门面模式 | 适配器模式 |
|------|----------|------------|
| 目的 | 为复杂子系统提供简单接口 | 转换接口，使不兼容的类能够协同工作 |
| 结构 | 门面类封装子系统的复杂逻辑 | 适配器作为两个不兼容接口之间的桥梁 |
| 关注点 | 简化接口，隐藏复杂性 | 接口的转换，兼容性 |
| 扩展性 | 中（主要简化接口，不改变系统结构） | 中（主要解决接口不兼容问题） |
| 适用场景 | 需要简化复杂系统接口的场景 | 需要集成已有类，但接口不兼容时 |

### 门面模式 vs 代理模式

| 特性 | 门面模式 | 代理模式 |
|------|----------|------------|
| 目的 | 为复杂子系统提供简单接口 | 控制对对象的访问，增强功能 |
| 结构 | 门面类封装子系统的复杂逻辑 | 代理类与原对象实现相同接口 |
| 关注点 | 简化接口，隐藏复杂性 | 访问控制，功能增强 |
| 扩展性 | 中（主要简化接口，不改变系统结构） | 高（可动态增强对象功能） |
| 适用场景 | 需要简化复杂系统接口的场景 | 需要控制对对象的访问或增强功能 |

### 门面模式 vs 装饰器模式

| 特性 | 门面模式 | 装饰器模式 |
|------|----------|------------|
| 目的 | 为复杂子系统提供简单接口 | 动态扩展对象功能 |
| 结构 | 门面类封装子系统的复杂逻辑 | 装饰器包装原对象，保持接口一致 |
| 关注点 | 简化接口，隐藏复杂性 | 功能的动态扩展 |
| 扩展性 | 中（主要简化接口，不改变系统结构） | 高（可动态添加多个装饰器） |
| 适用场景 | 需要简化复杂系统接口的场景 | 需要动态扩展对象功能而不修改原类 |

## 总结

门面模式是一种结构型设计模式，它为子系统中的一组接口提供一个统一的高层接口，简化了外部调用接口，隐藏了内部复杂性。这种模式的核心思想是通过引入一个门面类，将子系统的复杂逻辑封装起来，提供给客户端一个简单易用的接口。

### 核心思想

为复杂子系统提供一个简单的接口，隐藏子系统的内部复杂性，使客户端能够更方便地使用子系统。

### 主要角色

- **门面（Facade）**：提供一个统一的接口，封装子系统的复杂逻辑，简化客户端的调用。
- **子系统（Subsystem）**：包含多个类，每个类负责不同的功能，是门面类的依赖对象。
- **客户端（Client）**：通过门面类的简单接口与子系统交互，无需了解子系统的内部复杂性。

### 实现方式

1. **识别子系统**：识别需要封装的子系统及其接口。
2. **创建门面类**：创建一个门面类，封装子系统的复杂逻辑，提供简单的接口。
3. **客户端调用**：客户端通过门面类的简单接口与子系统交互。

### 优点

- **简化接口**：为复杂子系统提供一个简单易用的接口，减少客户端的学习成本。
- **隐藏复杂性**：隐藏子系统的内部复杂性，使客户端无需了解子系统的内部实现细节。
- **降低耦合**：减少客户端与子系统之间的耦合，提高系统的可维护性和可扩展性。
- **符合迪米特法则**：客户端只与门面类交互，不与子系统的具体类交互，减少了依赖关系。

### 缺点

- **可能违反开闭原则**：如果需要添加新的功能，可能需要修改门面类的代码。
- **可能成为上帝对象**：如果门面类封装了太多的功能，可能会导致门面类变得过于复杂，成为上帝对象。

### 适用场景

- **需要简化复杂系统接口的场景**：当系统的子系统非常复杂，客户端需要与多个子系统交互时。
- **需要降低客户端与子系统之间耦合的场景**：当客户端与子系统之间的耦合度较高，需要降低耦合时。
- **需要隐藏子系统内部实现细节的场景**：当需要隐藏子系统的内部实现细节，保护系统的安全性时。

### 实际应用

在实际开发中，门面模式常用于：

- **框架的API设计**：为复杂的框架提供简单易用的API，如Spring框架的JdbcTemplate。
- **系统集成**：当需要集成多个子系统时，使用门面模式简化集成过程。
- **数据库访问**：封装复杂的数据库操作，提供简单的接口，如ORM框架。
- **Web服务**：为复杂的Web服务提供简单的接口，如RESTful API。
- **日志系统**：封装复杂的日志记录逻辑，提供简单的接口，如log4j、slf4j。
