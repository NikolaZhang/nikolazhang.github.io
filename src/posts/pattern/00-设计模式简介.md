---
title: 设计模式简介
tag:
  - 设计模式
category: 设计模式
description: 设计模式简介
banner: http://image.nikolazhang.top/wallhaven-nrwq11.jpg
date: 2024-01-20

author: nikola
icon: paw

isOriginal: true
sticky: false
timeline: true
article: true
star: false
---

## 设计模式的分类

按照设计模式的目的，可以将设计模式划分为：

1. 创建型模式：  
    是对象实例化过程的抽象，通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息。
2. 结构型模式：  
    主要用于如何组合已有的类和对象以获得更大的结构，一般借鉴封装、代理、继承等概念将一个或多个类或对象进行组合、封装，以提供统一的外部视图或新的功能。
3. 行为型模式：  
   主要用于对象之间的职责及其提供的服务的分配，它不仅描述对象或类的模式，还描述它们之间的通信模式，特别是描述一组对等的对象怎样相互协作完成其中任一对象都无法单独完成的任务。

## 设计模式实例

### 创建型模式

1. 抽象工厂 Abstract Factory
2. 构建器 Builder
3. 工厂方法 Factory Method
4. 原型 Prototype
5. 单例 Singleton

### 结构型模式

1. 适配器 Adapter
2. 桥接 Bridge
3. 组合 Composite
4. 装饰者 Decorator
5. 外观 Facade
6. 享元 Flyweight
7. 代理 Proxy

### 行为型模式

1. 责任链 Chain of Responsibility
2. 命令 Command
3. 解释器 Interpreter
4. 迭代器 Iterator
5. 中介者 Mediator
6. 备忘录 Memento
7. 观察者 Observer
8. 状态 State
9. 策略 Strategy
10. 模板 Template Method
11. 访问者 Visitor

## 一句话

1. 单例模式(Singleton)：确保一个类仅有一个实例，并提供全局访问点。
2. 工厂方法(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类。
3. 抽象工厂(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类。
4. 建造者(Builder)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
5. 原型(Prototype)：通过复制原型实例来创建新的对象，而不是新建实例。
6. 代理(Proxy)：为其他对象提供一种代理以控制对这个对象的访问，如远程代理、虚拟代理、保护代理等。
7. 适配器(Adapter)：将一个类的接口转换成客户希望的另一个接口，使原本不兼容的类能够合作无间。
8. 桥接(Bridge)：将抽象部分与其实现部分分离，使它们都可以独立变化，例如实现系统可能有多种方式，但接口保持一致。
9. 组合(Composite)：允许你将对象组合成树形结构来表现“整体-部分”层次结构，用户对单个对象和组合对象的使用具有一致性。
10. 装饰器(Decorator)：动态地给对象添加额外的责任（功能），同时保持类的单一职责原则。
11. 门面(Facade)：为子系统中的一组接口提供一个统一的高层接口，简化了外部调用接口，隐藏内部复杂性。
12. 享元(Flyweight)：运用共享技术有效地支持大量细粒度的对象，减少系统中的对象数量，从而节省资源。
13. 观察者(Observer)：定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。
14. 模板方法(Template Method)：在一个抽象类中定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。
15. 责任链(Chain of Responsibility)：多个对象都有机会处理请求，避免请求的发送者和接收者之间的耦合关系。
16. 命令(Command)：将请求封装为一个对象，使得可以用不同的请求参数化客户端，支持可撤销操作和队列请求等功能。
17. 解释器(Interpreter)：提供了评估语言语法或表达式的方式，通常用于设计小型语言解析器。
18. 迭代器(Iterator)：提供一种顺序访问聚合对象元素的方法，而又不需要暴露其底层表示。
19. 中介者(Mediator)：定义一个中介对象来封装系列对象间的交互，降低对象间的耦合度。
20. 备忘录(Memento)：在不破坏封装性的前提下，捕获一个对象的内部状态并在需要时恢复它。
21. 状态(State)：允许对象在其内部状态改变时改变其行为，对象看起来似乎修改了它的类。
22. 策略(Strategy)：定义了一系列算法，并将每一个算法封装起来，使它们可以相互替换，让算法的变化独立于使用该算法的客户。
23. 访问者(Visitor)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。
